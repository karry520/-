在算法设计策略中，回溯法是比贪心和动态规划法更一般的方法。对于这样一类问题，其解可表示成一个n-元组$(x_0,x_1,\dots, x_{n-1})$，求满足约束条件的可行解，或进一步求使目标函数取最大（或最小）值的最优解问题，其中许多问题都可以用回溯回溯法求解。法是一种通过搜索状态空间树来求问题的可行解或最优解的方法。回溯法使用约束函数和限界函数来压缩需要实际生成的状态空间树的结点数，从而大大节省问题求解时间。

\section{一般方法}
\subsection*{基本概念}
贪心法和动态规划要求问题具有最优解具有最优子结构特性.贪心法求解还要求设计最优量度标准，但这并非易事。

为便于讨论，先定义下列与回溯法求解问题相关的术语。
\begin{enumerate}
	\item 显式约束和解空间。用于规定每个$x_i$的取值的约束条件称为显式约束(explicit constraint)。对给定的一个问题实例，显式约束规定了所有可能的元组，它们组成问题的候选解集，被称为该问题实例的解空间(solution space)。
	\item 隐式约束和判定函数。隐式约束给出了判定一个候选解是否为可行解的条件。一般需要从问题描述的隐式约束出发，设计一个判定函数(criterion function)。
	\item 最优解和目标函数。目标函数，也称代价函数(cost function)，用来衡量每个可行解的优劣。使目标函数取最大(或最小)值的可行解为问题的最优解。
	\item 问题状态和状态空间树。是描述问题解空间的树形结构。
\end{enumerate}
\subsection*{剪枝函数和回溯法}
如果问题的解空间可以用一棵状态空间树描述，那么通过搜索状态树可以寻找答案状态。最简单的做法是：使用某种树搜索方法，检查树中每个问题状态。如果是解状态，则用判定函数判定它是不是答案状态。对于最优化问题，在搜索过程中还需对每个答案结点计算其目标函数值，记录下其中最优者。为了提高搜索效率，在搜索过程中使用约束函数，可以避免无谓的搜索那么已知不停含答案状态的子树。如果是最优问题，还可以用限界函数剪去那些不可能包含最优答案结点的子树。约束函数和限界函数的目的相同，都是为了剪去不必要搜索的子树，减少问题求解所需实际生成的状态结点数，它们统称为剪枝函数。

\textbf{什么是约束函数？}一个约束函数是关于部分向量的函数$B_k(x_0,x_1,\dots,x_k)$它被定义为：如果可以断定Y的子树上不含有任何答案状态，则$B_k(x_0,x_1,\dots,x_k)$为false，否则为true。

事实上，状态空间树并不需要事先生成，而只需在求解的过程中，随着搜索算法的进展，逐个生成状态空间树的问题状态结点。

使用剪枝函数的深度优先生成状态空间树中结点的求解方法称为回溯法；广度优先生成结点，并使用剪枝函数的方法称为分枝限界法。

\textbf{递归回溯法}
\lstinputlisting[language=c++]{./chapter/算法设计与分析/code/RBacktrack.cpp}

\textbf{迭代回溯法}
\lstinputlisting[language=c++]{./chapter/算法设计与分析/code/IRB.cpp}
\subsection*{回溯法的效率分析}
回溯法的时间通常取决于状态空间树上实际生成的那部分问题状态的数目。对于元组长度为n的问题实例，若其状态空间树中结点总树为n!(或$2^n$或$n^n$)，则回溯算法的最坏情况时间复杂度可达$O(p(n)n!)$(或$O(p(n)2^n)$或$O(p(n)n^n)$)，这里$p(n)$是n的多项式，是生成一个结点所需的时间。

下面介绍一种用于估算回溯算法处理一个实例时，所实际生成的结点数的方法，叫做蒙特卡罗方法(Monte Carlo)。

\section{n-皇后}
\subsection*{问题描述}
n皇后问题要求在一个$n\times n$的棋盘上放置n个皇后，使得它们彼此不受“攻击”。按照国际象棋的规则，一个皇后可以攻击与其处在同一行、同一列或同一斜线上的其他棋子，n-皇后问题要求寻找在棋盘上放置这n个皇后的方案，使得它们中任何两个都不在同一行、同一列或同一斜线上。
\subsection*{回溯法求解}
一个问题能够用回溯法求解，首先，它的解具有n-元组形式；其次，问题提供显式约束来确定状态空间树，并提供隐式约束来判定可行解；最后，应能设计有效的约束函数，缩小检索空间。
\subsection*{n-皇后算法}
\begin{enumerate}
	\item 确定解的结构形式。假定将第i个皇后放在第i行上，这样便可用n-元组$(x_0,x_1,\dots,x_{n-1})$表示n-皇后问题的解，其中$x_i$表示第i行的皇后所处的列号($0\leq x_i\leq n$)
	\item 显式约束。$S_i=\{0,1,\dots,n-1 \},0\leq i<n$且$x_i\ne x_j(0\leq i,j<n,i\ne j)$，状态空间树则表现为排列树。
	\item 隐式约束。对任意$0\leq i,j<n$当$i\ne j$时，$|i-j|\ne |x_i-x_j|$。与此相对应的解空间大小为n!。
\end{enumerate}
\section{子集和数}
\subsection*{问题描述}
已知n个不同的正数$w_i(0\leq i\leq n-1)$的集合，求该集合的所有满足条件的子集，使得每个子集中的正数之和等于另一个给定的正数M。
\subsection*{回溯法求解}
对于子集和数问题，可采用两种不同的解结构形式
\begin{enumerate}
	\item 可变长度元组。当采用可变长度元组表示解时，表示为一个k-元组$(x_0,x_1,\dots,x_{k-1}),0\leq k\leq n$。元组的每个分量的取值可以是元素值，也可以是选入子集的正数的下标。
	\item 固定长度元组。固定长度n-元组$(x_0,x_1,\dots,x_{n-1}),x_i\in \{0,1\},0\leq i<n$。
\end{enumerate}

子集和数的约束函数$B_k$。假定采用固定长度元组的解结构，
\begin{equation}
	B_k(x_0,x_1,\dots,x_{n-1})=\mathrm{true},\  \text{当且仅当}\sum_{i=0}^{k-1}w_ix_i+\sum_{i=k}^{n-1}w_i\geq M
\end{equation}
\subsection*{子集和数算法}
\section{图的着色}
\subsection*{问题描述}
图的m-着色优化问题——若一个图最少需要m种颜色才能使图中任意相邻的2个顶点着不同颜色，则称这个数m为该图的着色数。求一个图的最小色数m的问题称为m-着色优化问题。
\subsection*{回溯法求解}
设无向图$G=(V,E)$采用如下定义的邻接矩阵表示：
\begin{equation}
	a[i][j]=\begin{cases}
	 1\quad &\text{如果}(i,j)\in E\\
	 0\quad &\text{其他}
	\end{cases}
\end{equation}
采用n-元组$(x_0,x_1,\dots,x_{n-1})$表示图$G$的m-着色问题的解。每个$x_i\in \{1,2,\dots,m\}0\leq i<n$，表示结点i的颜色，这就是显式约束。隐式约束可描述为：如果边$(i,j)\in E$，则$x_i\ne x_j$。
\subsection*{图着色算法}
\section{哈密顿环}
\subsection*{问题描述}
连通图G的一个哈密顿环是图G的一个回路，它经过图中的每个结点，且只经过一次。
\subsection*{哈密顿环算法}
对于n个结点的图$G=(V,E)$的哈密顿环问题，可采用n-元组表示问题的解$(x_0,x_1,\dots,x_{n-1})$。每个$x_i\in \{0,1,\dots,n-1\},0\leq i<n$，代表路径上一个结点的编号，这就是显式约束。因此解空间大小为$n^n$。其隐式约束可描述为：$x_i\ne x_j(0\leq i,j<n,i\ne j)$且$(x_i,x_{i+1})\in E,x_i,x_{i+1}\in V(i=0,i,\dots,n-2)$又$(x_{n-1},x_0)\in E$。
\section{0/1背包}
前面所讨论的使用回溯法求解的问题，n-皇后问题、子集和数问题、m-着色问题及哈密顿环问题有相同的特征，即问题的求解目标都是求满足约束条件的全部可行解。所有算法都使用约束函数剪去已能确信不含答案结点的子树。如果只求一个可行解，则只需对这些算法稍加修改，使得在求得第一个可行解后算法终止。0/1背包和批处理作业调度问题是最优化问题，还需要使用限界函数剪去已能确信不含最优答案结点的子树。
\subsection*{问题描述}
0/1背包问题看似简单，但却是一个困难问题，所谓困难问题是指一般来说难以设计一个算法使得最球情况时间为多项式。下面讲0/1背包问题的回溯算法。
\subsection*{回溯法求解}
0/1背包问题的解可用一个n-元组表示：
\begin{equation}
	X=(x_0,x_1,\dots,x_{n-1})\ x_0=0\text{或}1(0\leq i<n)
\end{equation}
式中，$x_1=1$表示将第i件物品装入背包，$x_0=0$表示该物品不装入背包。约束条件是
\begin{equation}
	\sum_{i=0}^{n-1}w_ix_i\leq M\quad w_i>0,x_i=0\text{或}1(0\leq i<n)
\end{equation}
回溯法本质上是一种深度优先搜索状态空间树的算法，如果不引入剪枝函数，它是穷举算法。引入适当的限界函数使其成为一种启发式算法。

约束函数可定义为
\begin{equation}
B_k(x_0,x_1,\dots,x_k)=\mathrm{true}\ ,\text{当且仅当}\sum_{i=0}^{n-1}w_ix_i\leq M
\end{equation}
\subsection*{限界函数}
0/1背包问题是一个最优化问题，问题的最优解是使目标函数值最大的可行解。使用约束函数剪去的是不含可行解的子树，而使用限界函数可以进一步剪去那些不含最优解的分枝。

设0/1背包回溯算法当前位于状态空间树的结点X处，cw是背包的当前重量，cp是当前已装入背包的物品的总收益。如果背包的载重量为M，则剩余裁重量是M-cw，设此时还有编号为$k+1,\dots,n-1$的物品尚未考察。如果使用贪心法，计算以剩余载重和剩余物品构成的一般背包问题的最优解，设该最大收益为rp，那么bp=cp+rp便可作为以X为根的子树上所有可能的答案结点的目标函数值的上界。

定义一个最优解值的下界估计值变量L，L的初值可以为0.在算法执行中，一旦遇到一个答案结点，便计算该答案结点的收益值fp。令$L=\max \{L,fp\}$，因此，L始终保存迄今为止已经搜索到的窃案结点中收益最大值，0/1背包的最优解值必定大于等于L。对于状态空间树中任一结点X，若其上界函数值bp<L，则可以断定X子树上不含最优答案结点，可以剪去以X为根的子树。
\subsection*{0/1背包算法}
\section{批处理作业调度}
\subsection*{问题描述}
假定处理一个作业需要执行若干项不同类型的任务，每一类任务只能在某一台设备上执行。设一条流水线上有n个作业$j=\{J_0,j_1,\dots, J_{n-1}\}$和m台设备$P=\{P_1,P_2,\dots, P_m\}$。每个作业需依次执行m个任务，其中第$j(1\leq j\leq m)$个任务只能在第j台设备上执行。如果将这$n\times m$个任务分配给m台设备，使得这n个作业都能顺利完成，这就是流水线作业调度问题。
\subsection*{回溯法求解}
\subsection*{批处理作业调度算法}
\section{本章小结}
回溯法以深度优先次序生成状态空间树中的结点，并使用剪枝函数减少实际生成的结点数。回溯法是一种广泛适用的算法设计技术。只要问题的解是元组形式，可以用状态空间树描述，并采用判定函数识别答案结点，就能采用回溯法求解。回溯法使用约束函数剪去不含可行解的分枝。当使用回溯法求最优化问题时，需设计限界函数，用于剪去不含最优解的分枝。约束函数和限界函数通称为剪枝函数。回溯法的求解时间常因实例而异，其计算时间可用蒙特卡罗方法估算。