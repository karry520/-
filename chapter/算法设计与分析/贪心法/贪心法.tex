贪心法求解最优化问题。本章讨论运用贪心法求解的一类问题的特征及求解方法。读者熟知的某些图算法，例如，最小代价生成树问题和单源最短路径问题可用贪心法求解。本章讨论的这些问题，如背包问题、最佳合并模式及带时限的作业排序问题等，都是贪心求解的典型问题。通过分析这些问题，掌握贪心法的基本要素，学会如何使用贪心策略设计算法。
\section{一般方法}
一般来讲，如果一个问题适合用贪心法求解，问题的解应可表示成一个n-元组$(x_0,x_1,\dots,x_{n-1})$，其中每个分量$x_i$取自某个值集$S$，所有允许的n-元组组成一个候选集。问题中应给出用于判定一个候选解是否是可行解的约束条件，满足约束条件的候选解称为可行解。同时还给定一个数值函数称为目标函数，用于衡量每个可行解的优劣，使目标函数取最大(或最小)值的可行解为最优解。

贪心法是一种求解最优化问题的算法设计策略。贪心法是通过分步决策的方法来求解问题的。贪心法在求解问题的每一步上做出某种决策，产生n-元组解的一个分量。贪心法要求根据题意，选定一种最优量度标准，作为选择当前分量值的依据。这种在贪心法每一步上用做决策依据的选择准则被称为最优量度标准或贪心准则，也称贪心选择性质。这种量度标准通常只考虑局部最优性。

在初始状态下，解向量$solution=\emptyset$，其中未包含任何分量。使用最优量度标准，一次选择一个分量，逐步形成解向量$(x_0,x_1,\dots,x_{n-1})$。在根据最优量度标准选择分量的过程中，还需要使用一个可行解判定函数。

贪心法可用如下的算法框架描述
\lstinputlisting[language=c++]{./chapter/算法设计与分析/code/Greedy.cpp}

由于贪心策略并不是从整体上加以考虑的，它所做出的选择只是当前看似最佳的选择，这种选择仅依赖于以前的选择，但不依赖于以后的选择。对于一个具体的应用问题，无法确保贪心法一定产生最优解。因此，对于一个贪心算法，必须进一步证明该算法的每一步上所做出的选择，都必然最终导致问题的一个整体最优解。
\section{背包问题}
\subsection*{问题描述}
已知一个载重为M的背包和n件物品，第i件物品的重量为$w_i$，如果将第$i$件物品全部装入背包，将有收益$p_i$，这里，$w_i>0,p_i>0,0\leq i\leq n$。所谓背包问题，是指求一种最佳 装载方案，使得收益最大。
\begin{enumerate}
	\item 物品不能分割(0/1背包)
	\item 物品能分割(此处要讲的)
\end{enumerate}

\subsection*{贪心法求解}
背包问题的解可以表示成一个n-元组：$X=\{x_0,x_1,\dots,x_{n-1}\},0\leq x_i\leq 1,0\leq i<n$。约束条件
\begin{equation}
	\sum_{i=0}^{n-1}w_ix_i\leq M\quad w_i>0,0\leq x_i\leq 1,0\leq i<n
\end{equation}
目标函数
\begin{equation}
	\mathrm{max}\ \sum_{i=0}^{n-1}p_ix_i\quad p_i>0,0\leq x_i\leq 1,0\leq i<n
\end{equation}
贪心准则：选择使单位重量收益最大的物品装入背包。
\section{带时限的作业排序}
\subsection*{问题描述}
设有一个单机系统、无其他资源限制且每个作业运行相等时间，不妨假定每个作业运行1个单位时间。现有n个作业，每个作业都有一个截止期限$d_i>0,d_i$为整数。如果作业能够在截止期限之内完成，可获得$p_i>-$的收益。问题要求得到一种作业调试方案，该方案给出作业的一个子集和该作业子集的一种排列，使得若按照这种排列次序调度作业运行，该子集中的每个作业都能如期完成，并且能够获得最大收益。
\subsection*{贪心法求解}
设n个作业以编号$0\sim n-1$标识，每个作业有唯一的作业编号，$I=\{0,1,\dots, n-1\}$是n个输入作业的集合。带时限作业排序问题的解是$I$的一个子集$X$，可表示成一个$n-$元组：$X=(x_0,x_1,\dots,x_{r-1}),0<r\leq n$。每个$x_i(0\leq x_i\leq n-1)$是一个作业编号。

贪心准则：一种直观而局部的想法是选择一个作业加入部分解向量中，在不违反截止时限的前提下，使得至少就当前而言，已选入部分解向量中的那部分作业的收益之和最大。为满足这一最度标准，只需先将输入作业集合$I$中的作业按收益的非增次序排列，即$p_0\geq p_1\geq \dots \geq p_{n-1}$。

带时限作业排序的贪心算法
\lstinputlisting[language=c++]{./chapter/算法设计与分析/code/GreedyJob.cpp}

\subsection*{一种改进算法}
改进的可行解判定方法的基本思想是：令$b=\{n,\max\{d_i|0\leq i\leq n-1 \} \}$，b是一种可行的作业调度方案所需的最大时间。

最优量度标准仍然采取使得部分解向量的收益最大这一准则，设作业已按收益的非增次序排列，作业i的时限是$d_i$，为它所分配的时间片是$[\gamma -1,\gamma]$，其中$\gamma$是使$0\leq \gamma\leq d_i$的最大整数且时间片$[\gamma-1,\gamma]$是空闲的。具体做法是：为收益最大的作业0分配时间片$[d_0-1,d_0]$，为收益次大的作业1分配作业时，首先考虑时间片$[d_1-1,d_1]$，如果该时间片已分配，再考虑前一个时间片$[d_1-2,d_1-1]$，依次向前寻找第一个空闲的时间片分配之。

总之，这种方法采取的作业调度原则是尽可能推迟一个作业的执行时间。
\section{最佳合并模式}
\subsection*{问题描述}
在数据结构中介绍的构造哈夫曼树的哈夫曼算法和设计K路合并外排序最佳方案的方法都属于最佳合并模式问题。两路合并外排序算法通过反复执行将两个有序子文件合并成一个有序文件的操作，最终将n个长度不等的有序子文件合并成一个有序子文件。
\subsection*{贪心法求解}
两路合并树表达的合并方案确定了合并排序过程中所需读/写的记录总数，这个量正是该两路合并树的带权外路径长度。带权外路径长度是针对扩充二叉树而言的。扩充二叉树中除叶子结点外，其余结点都必须有两个孩子。扩充二叉树的带权外路径长度定义为：
\begin{equation}
	WPL=\sum_{k=1}^{m}w_{k}l_k
\end{equation}
式中，m是叶子结点的个数，$w_k$是第k个叶子结点的权，$l_k$是从根到叶子结点的路径长度。

贪心法是一种多步决策的算法策略，一个问题能够使用贪心法求解，除了具有贪心法问题的一般特性外，关键问题是确定最优量度标准。两路合并最佳模式问题的最优量度标准为带权外路径长度最小。具体做法是在有序子文件集合中，选择两个长度最小的子文件合并之。


\section{最小代价生成树}
\subsection*{问题描述}
一个无向连通图的生成树是一个极小连通子图，它包括图中全部结点，并且有尽可能少的边。一棵生成树的代价是树中各条边止的代价之和。一个网络的各生成树中，具有最小代价生成树称为该网络的最小代价生成树(minimum-cost spanning tree)。
\subsection*{贪心法求解}
将贪心策略用于求解无向连通图的最小代价生成树时，核心问题是需要确定贪心准则。根据最优量度标准，算法的每一步从图中选择一条符合准则的边，共选择n-1条边，构成无向连通图的一棵生成树。贪心法求解的关键是该量度标准必须足够好。它应当保证依据此准则选出n-1条边构成原图的一棵生成树，必定是最小代价生成树。

最简单的最优量度标准是：选择使得迄今为止已入选S中边的代价之处增量最小的边。对于最优量度标准的不同解释将产生不同的构造最小代价生成树算法。对于上述量度标准有两种可能的理解，它们是普里姆(Prim)算法和克鲁斯卡尔(Kruskal)算法。

克鲁斯卡尔算法的贪心准则是：按边代价的非减次序考察E中的边，从中选择一条代价最小的边$e=(u,v)$。这种做法使得算法在构造生成树的过程中，边集S
代表的子图不一定是连通的。普里姆算法的贪心准则是：在保证S所代表的子图是一棵树的前提下选择一条最小代价的边$e=(u,v)$。
\section{单源最短路径}
最短路径是另一种重要的图算法。有两类不同的最短路径问题：单源最短路径问题和所有结点间的最短路径问题。对于这两类问题，存在不同的求解算法。
\subsection*{问题描述}
单源最短路径问题是：给定带权的有向图$G=(V,E)$和图中结点$s\in V$，求从s到其余各结点的最短路径，其中，s称为源点。
\subsection*{贪心法求解}
用贪心法的观点看，从源点到另一个结点的任何一条路径均可视为一个可行解，其中长度最短的路径是从源点到该结点的最短路径。从源点到其余每个结点的最短路径构成了单源最短路径问题的最优解。

\textbf{迪杰斯特拉}(Dijkstra)提出了按路径长度的非递减次序逐一产生最短路径的算法：首先求得长度最短的一条最短路径，再求得长度次短的一条最短路径，其余类推，直到从源点到其他所有结点之间的最短路径都已求得为止。也就是说，对于最终求得的最优解$L=(L_1,L_2,\dots, L_{n-1})$，算法先求得其中最短路径，然后再求次短的.......

设$S=\{v_0,v_1,\dots,v_k \}$是已经求得的最短路径的结点集合，一个结点$v_i$属于S当且仅当从源点$s$到$v_i$的最短路径已经计算。单源最短路径的最优量度标准是：使得从s到S的所有结点的路径长度之和增量最小。所以迪杰斯特拉算法总是在集合$V-S$中选择“当前最短路径”长度最小的结点加入集合S中。
\section{磁带最优存储}
\subsection*{单带最优存储问题描述}
设有n个程序编号分别为$0,1,\dots, n-1$，要存放在长度为L的磁带上，程序i在磁带上存储长度为$a_i,0\leq i<n,\sum_{i=0}^{i-1}a_i\leq L$。假定存放在磁带上的程序随时可能被检索，且磁带在每次检索前均已倒带到最前端。那么，如果n个程序在磁带上的存放次序为$\gamma=(\gamma_0,\gamma_1,\dots,\gamma_{n-1})$，则检索程序$\gamma_k$所需时间$t_k$与$\sum_{i=0}^{k}a_{\gamma_i}$成正比。假定每个程序被检索的概率相等，则平均检索时间(mean retrieval time,MRT)定义为$\frac{1}{n}\sum_{k=0}^{n-1}t_k$。单带最优存储问题是求这n个程序的一种排列，使得MRT有最小值。这也等价于求使$D(\gamma)=\sum_{k=0}^{n-1}\sum_{i=0}^{k}a_{\gamma_i}$有最小值的排列。
\subsection*{贪心法求解}
贪心法通过逐个选择解向量的分量求解问题。一个问题可用贪心法求解的关键是设计最优量度标准。一种可以考虑的量度标准是：计算迄今为止已选的那部分程序D值，选择下一个程序的标准应使得该值的增加最小。容易看到，这一量度标准等价于将程序按长度非减次序排列后依次存放。
\subsection*{多带最优存储问题描述}
可以将单带存储问题扩展到多带存储问题。设有$m(m>1)$条磁带$T_0,\dots,T_{m-1}$和n个程序，要求将这n个程序分配到这m条磁带上，令$I_j(0\leq j<m)$是存放在第j条磁带上的程序子集的某种排列，$D(I_j)$的定义与前面相同，那么，求m条磁带上检索一个程序的平均检索时间的最小值等价于求$\sum_{0\leq j<m}D(I_j)$的最小值。令$TD=\sum_{0\leq j<m}D(I_j)$。多带最优存储问题是求n个程序在m条磁带上的一种存储方式，使得TD有最小值。
\subsection*{贪心法求解}
在多带情况下计算最优平均检索时间，可以先将程序按长度的非减次序排列，即$a_0\leq a_1\leq \dots\leq a_{n-1}$，其中$a_i(0\leq i < n)$是程序i的长度。从程序0和磁带$T_0$开始分配，一般将程序i存放在磁带i mod m上。

\section{贪心法的要素}
贪心法被用于求解一类最优化问题，它使用多步决策求解方法，根据选定的最优量度标准（也称贪心准则），每次确定问题解的一个分量。由于贪心法每步所做的选择只是当时的最佳选择，因此并不一定总能产生最优解。一般说来，适于用贪心法求解的问题大都具有下面两个特性：最优量度标准和最优子结构。
\subsection*{最优量度标准}
是使用贪心法求解问题的核心问题。贪心法的当前选择可能会依赖于已经做出的选择，但不依赖于尚未做出的选择和子问题，因此它的特征是自顶向下，一步一步地做出贪心决策。虽然贪心算法的每步选择也将问题简化为一个规模更小的子问题，但由于贪心算法每步选择并不信赖子问题的解，每步选择只按最优量度标准进行，因此，对于一个贪心算法，必须证明所采用的最度标准能够导致一个整体最优解。
\subsection*{最优子结构}
当一个问题的最优解中包含了子问题的最优解时，则称该问题具有最优子结构特性。一般而言，如果一个最优化问题的解结构具有元组形式，并具有最优子结构特性，我们可以尝试选择量度标准。如果经证明(一般是归纳法)，确认该量度标准能导致最优解，便可容易地按算法框架设计出求解该问题的具体的贪心算法。

并非对所有具有最优子结构特性的最优化问题，都能够幸运地找到最优量度标准，此时考虑用动态规划法求解。

\section{本章小结}
贪心法是求解最优化问题的非常有用的算法设计技术。一个问题能够使用贪心策略的条件是该问题的解是向量结构的，具有最优子结构特性，还要求能够通过分析问题获取最优量度标准。但是，按照该量度标准依次生成解的分量所形成的解是否确实是最优解仍需证明。