贪心法求解最优化问题。本章讨论运用贪心法求解的一类问题的特征及求解方法。读者熟知的某些图算法，例如，最小代价生成树问题和单源最短路径问题可用贪心法求解。本章讨论的这些问题，如背包问题、最佳合并模式及带时限的作业排序问题等，都是贪心求解的典型问题。通过分析这些问题，掌握贪心法的基本要素，学会如何使用贪心策略设计算法。
\section{一般方法}
一般来讲，如果一个问题适合用贪心法求解，问题的解应可表示成一个n-元组$(x_0,x_1,\dots,x_{n-1})$，其中每个分量$x_i$取自某个值集$S$，所有允许的n-元组组成一个候选集。问题中应给出用于判定一个候选解是否是可行解的约束条件，满足约束条件的候选解称为可行解。同时还给定一个数值函数称为目标函数，用于衡量每个可行解的优劣，使目标函数取最大(或最小)值的可行解为最优解。

贪心法是一种求解最优化问题的算法设计策略。贪心法是通过分步决策的方法来求解问题的。贪心法在求解问题的每一步上做出某种决策，产生n-元组解的一个分量。贪心法要求根据题意，选定一种最优量度标准，作为选择当前分量值的依据。这种在贪心法每一步上用做决策依据的选择准则被称为最优量度标准或贪心准则，也称贪心选择性质。这种量度标准通常只考虑局部最优性。

在初始状态下，解向量$solution=\emptyset$，其中未包含任何分量。使用最优量度标准，一次选择一个分量，逐步形成解向量$(x_0,x_1,\dots,x_{n-1})$。在根据最优量度标准选择分量的过程中，还需要使用一个可行解判定函数。

贪心法可用如下的算法框架描述
\lstinputlisting[language=c++]{./chapter/算法设计与分析/code/Greedy.cpp}

由于贪心策略并不是从整体上加以考虑的，它所做出的选择只是当前看似最佳的选择，这种选择仅依赖于以前的选择，但不依赖于以后的选择。对于一个具体的应用问题，无法确保贪心法一定产生最优解。因此，对于一个贪心算法，必须进一步证明该算法的每一步上所做出的选择，都必然最终导致问题的一个整体最优解。
\section{背包问题}
\subsection*{问题描述}
已知一个载重为M的背包和n件物品，第i件物品的重量为$w_i$，如果将第$i$件物品全部装入背包，将有收益$p_i$，这里，$w_i>0,p_i>0,0\leq i\leq n$。所谓背包问题，是指求一种最佳 装载方案，使得收益最大。
\begin{enumerate}
	\item 物品不能分割(0/1背包)
	\item 物品能分割(此处要讲的)
\end{enumerate}

\subsection*{贪心法求解}
背包问题的解可以表示成一个n-元组：$X=\{x_0,x_1,\dots,x_{n-1}\},0\leq x_i\leq 1,0\leq i<n$。约束条件
\begin{equation}
	\sum_{i=0}^{n-1}w_ix_i\leq M\quad w_i>0,0\leq x_i\leq 1,0\leq i<n
\end{equation}
目标函数
\begin{equation}
	\mathrm{max}\ \sum_{i=0}^{n-1}p_ix_i\quad p_i>0,0\leq x_i\leq 1,0\leq i<n
\end{equation}
贪心准则：选择使单位重量收益最大的物品装入背包。
\section{带时限的作业排序}
\subsection*{问题描述}
设有一个单机系统、无其他资源限制且每个作业运行相等时间，不妨假定每个作业运行1个单位时间。现有n个作业，每个作业都有一个截止期限$d_i>0,d_i$为整数。如果作业能够在截止期限之内完成，可获得$p_i>-$的收益。问题要求得到一种作业调试方案，该方案给出作业的一个子集和该作业子集的一种排列，使得若按照这种排列次序调度作业运行，该子集中的每个作业都能如期完成，并且能够获得最大收益。
\subsection*{贪心法求解}
\section{最佳合并模式}
\subsection*{问题描述}
\subsection*{贪心法求解}
\section{最小代价生成树}
\subsection*{问题描述}
\subsection*{贪心法求解}
\section{单源最短路径}
\subsection*{问题描述}
\subsection*{贪心法求解}
\section{磁带最优存储}
\subsection*{问题描述}
\subsection*{贪心法求解}
\section{贪心法的要素}
\subsection*{最优量度标准}
\subsection*{最优子结构}